---
title: "Deep React"
description: "Notes on React Deepdives"
pubDate: "Jun 11, 2023"
heroImage: "/react-logo.gif"
draft: false
---
* Either wrap a method dependecy in a `useCallback` or move the method within the body of the effect:
  ![useCallback removal of method deps](./useCallback1.png)
* If you’re writing a `custom Hook`, <u>it’s recommended to wrap any functions that it returns into `useCallback`.</u> This ensures that the consumers of your Hook can optimize their own code when needed.
* If you forget the dependency array, `useCallback` will return a new function every time.
* The `context` from a `useContext` itself does not hold the information, it only represents the kind of information you can provide or read from components.
* React automatically re-renders components that read some context if it changes.
* `useContext()` always looks for the closest provider <u>above</u> the component that calls it. It searches upwards and does not consider providers in the component from which you’re calling `useContext().`
* Extract Contexts into Reducers and Hooks to expose the methods to scale them:
  
  <br/><iframe src="https://codesandbox.io/embed/crimson-glitter-hwl4y7?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="crimson-glitter-hwl4y7"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
  Moving the `useContext` into a hook doesn’t change the behavior in any way, but it lets you later split these contexts further or add some logic to these functions. Now all of the context and reducer wiring is in TasksContext.js. This keeps the components clean and uncluttered, focused on what they display rather than where they get the data.

* Wrapping `Context` values in `useCallback` and `useMemo` will help optimize the values in larger applications:
  ![Optimized context usage](./optimizeUseCallback.png)
* Inline style properties are written in camelCase. For example, HTML `<ul style="background-color: black">` would be written as `<ul style={{ backgroundColor: 'black' }}>`  in your component.
* `useEffect` is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* If you’re not trying to `synchronize` with some external system, you probably <u>don’t need an Effect.</u>
* <u>You don’t need Effects to transform data for rendering.</u> For example, let’s say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will “commit” these changes to the DOM, updating the screen. Then React will run your Effects. If your Effect also immediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.
* <u>You don’t need Effects to handle user events.</u> For example, let’s say you want to send an `/api/buy POST` request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don’t know what the user did (for example, which button was clicked). This is why you’ll usually handle user events in the corresponding event handlers.
* When something can be calculated from the existing props or state, don’t put it in state. Instead, calculate it during rendering.
* 